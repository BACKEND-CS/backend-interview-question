# 목차

## 데이터베이스에서 인덱스를 사용하는 이유 및 장단점에 대해 설명해주세요.

<br>

### ① 목적

RDBMS에서 데이터 조회 성능 향상을 위해 사용

테이블의 컬럼을 색인화 하여 따로 파일로 저장한다.

→ 해당 테이블의 레코드(모든 행)을 Full scan하지 않는다.

→ 색인화 된 인덱스 파일 검색으로 검색 속도 향상

### ② 장점

검색 속도 향상

### ③ 단점

1. **타 성능에 악영향**
    
    인덱스는 데이터 조회(SELECT)를 제외한 모든 동작,
    
    INSERT, UPDATE, DELETE 성능에 영향을 미친다.
    
    → 인덱스를 걸어둔 컬럼의 데이터가 바뀌면 인덱스 테이블의 수정도 필요하기 때문에, 데이터의 삽입 / 수정 / 삭제 작업의 두 번 이루어지게 된다.
    

2. **추가 저장 공간 필요**
    
    DB에 저장된 데이터의 주소를 인덱스의 Key 값으로 가지려면 별도의 공간에 저장하므로 추가 저장 공간이 필요하다.
    
    때문에 인덱스를 사용하는 시스템을 설계할 때, 인덱스 영역을 전체 테이블 영역의 30 ~ 50%까지 잡아 놓을 만큼 저장 공간이 꽤나 많이 필요하다.
    

3. **공수 필요**
    
    인덱스를 생성하고 주기적으로 관리할 인력과 시간이 들어간다.
    
    ❓공수 : 일정한 작업에 필요한 인원 수를 노동 시간이나 노동 일로 나타낸 수치
   
<br>

## 트랜잭션에 대해서 설명해주세요.

<br>

데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위이다.

다른 말로, 작업의 완전성을 보장해주는 것이다. 

논리적인 작업을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 한다.

<br>

## ACID에 대해서 설명해주세요.

<br>

### ① 정의

ACID는 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질

### ② 특징

1. 원자성(Atomicity)
    
    트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 된다.
    
    트랜잭션의 연산은 모든 연산이 완벽히 수행되어야 하며, 중간에 어떠한 문제가 발생한다면 트랜잭션은 실패해야 한다.
    
2. 일관성(Consistency)
    
    트랜잭션이 완료된 후에도, 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.
    
3. 고립성(Isolation)
    
    둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.
    
4. 지속성(Durability)
    
    트랜잭션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 한다.

<br>

## 트랜잭션 격리 수준(Transaction Isolation Levels)에 대해서 설명해주세요.

<br>

### ① 정의

트랜잭션들끼리 일관성 있는 데이터를 얼마나 허용할 것인지 정해놓은 수준

고립 수준이 높을수록 일관성은 보자되나 그만큼 동시성이 떨어져 성능은 하락

### ② 필요성

효율적인 Locking 방법을 위해 필요

### ③ 이상 현상 종류

1. Dirty Read
    
    어떤 트랜잭션에서 아직 실행이 끝나지 않은 트랜잭션에 의한 변경사항을 보게 되는 경우
    
2. Non Repeatable Read
    
    어떤 트랜잭션이 같은 쿼리를 2번 실행하는데 그 사이에 다른 트랜잭션이 수정/삭제를 하는 경우
    
3. Phantom Read
    
    어떤 트랜잭션이 같은 쿼리를 2번 실행하는데 그 사이에 없던 레코드가 추가되어 같은 쿼리에 다른 값이 나오는 경우
    
    
### ④ 격리 수준 단계

1. **Read Uncommitted(Level 0)**
    
    트랜잭션이 처리중이거나, 아직 commit 되지 않은 데이터를 다른 트랙잭션이 조회 하는 것을 허용하는 수준
    
    ex) 트랜잭션1이 A라는 데이터를 B로 변경하는 동안 트랜잭션2가 데이터 B를 읽을 수 있다.
    
    ➖ Dirty Read, Non Repeatable Read, Phantom Read 발생 가능
    
2. **Read Committed(Level 1)**
    
    트랜잭션 수행이 완료되어 commit이 이루어진 트랜잭션만 다른 트랜잭션에서 조회가 가능한 수준
    
    ex) 트랜잭션1이 A라는 데이터를 B로 변경하는 동안 트랜잭션2는 해당 데이터에 접근이 불가능하다.
    
    ➖ Non Repeatable Read, Phantom Read 발생 가능
    
3. **Repeatable Read(Level 2)**
    
    특정 트랜잭션에서 조회하고 있는 데이터는 다른 트랜잭션에서 수정/삭제가 불가능한 수준
    
    데이터 삽입은 가능하다.
    
    ➖ Phantom Read 발생 가능
    
4. **Serializable(Level 3)**
    
    특정 트랜잭션에서 조회 하고 있는 데이터는 다른 트랜잭션에서 수정/삭제/삽입 모두 불가능한 수준
    
    모든 이상 현상 방지 가능하나 동시성이 떨어져서 성능 하락
    
<br>

## 정규화에 대해서 설명해주세요.

<br>

### ① 정의

관계형 데이터 모델에서 중복과 변경 이상이 최소화도록 릴레이션의 구조, 스키마를 변경해 가는 과정

### ② 목적

- 데이터의 중복을 없애면서 불필요한 데이터를 최소화시킨다.
- 무결성을 지키고, 이상 현상을 방지한다.
- 테이블 구성을 논리적이고 직관적으로 할 수 있다.
- 데이터베이스 구조를 확장에 용이해진다.

### ③ 단계

- 제 1정규화(1NF)
    
    테이블 컬럼이 원자값(하나의 값)만 갖도록 테이블을 분리
    
    1. 각 컬럼이 하나의 속성만을 가져야 한다.
   
    2. 하나의 컬럼은 같은 종류나 타입(type)의 값을 가져야 한다.
    
    3. 각 컬럼이 유일한(unique) 이름을 가져야 한다.
    
    4. 컬럼의 순서가 상관없어야 한다.

- 제 2정규화(2NF)
    
    테이블의 모든 컬럼이 완전 함수적 종속을 만족하도록 테이블을 분리
    
    기본키가 복합키 일 때, 그 중 하나의 키만으로 다른 컬럼을 결정지으면 안됨
    
    
    1. 제 1정규형 만족
    
    2. 어떤 후보키에도 속하지 않는 모든 애트리뷰트들이 기본키에 완전 함수적 종속 만족
    
- 제 3정규화(3NF)
    
    테이블의 모든 컬럼이 이행적 종속을 만족하지 않도록 테이블을 분리
    
    1. 제 2정규형 만족
    
    2. 키가 아닌 애트리뷰트들이 기본키에 직접 종속
