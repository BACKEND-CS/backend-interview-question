# 목차

## 데이터베이스에서 인덱스를 사용하는 이유 및 장단점에 대해 설명해 주세요.

<br>

### ① 목적

RDBMS에서 데이터 조회 성능 향상을 위해 사용

테이블의 컬럼을 색인화 하여 따로 파일로 저장한다.

→ 해당 테이블의 레코드(모든 행)을 Full scan하지 않는다.

→ 색인화 된 인덱스 파일 검색으로 검색 속도 향상

### ② 장점

검색 속도 향상

### ③ 단점

1. **타 성능에 악영향**
    
    인덱스는 데이터 조회(SELECT)를 제외한 모든 동작,
    
    INSERT, UPDATE, DELETE 성능에 영향을 미친다.
    
    → 인덱스를 걸어둔 컬럼의 데이터가 바뀌면 인덱스 테이블의 수정도 필요하기 때문에, 데이터의 삽입 / 수정 / 삭제 작업의 두 번 이루어지게 된다.
    

2. **추가 저장 공간 필요**
    
    DB에 저장된 데이터의 주소를 인덱스의 Key 값으로 가지려면 별도의 공간에 저장하므로 추가 저장 공간이 필요하다.
    
    때문에 인덱스를 사용하는 시스템을 설계할 때, 인덱스 영역을 전체 테이블 영역의 30 ~ 50%까지 잡아 놓을 만큼 저장 공간이 꽤나 많이 필요하다.
    

3. **공수 필요**
    
    인덱스를 생성하고 주기적으로 관리할 인력과 시간이 들어간다.
    
    ❓공수 : 일정한 작업에 필요한 인원 수를 노동 시간이나 노동 일로 나타낸 수치
   
<br>

## 트랜잭션에 대해서 설명해 주세요.

<br>

데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위이다.

다른 말로, 작업의 완전성을 보장해주는 것이다. 

논리적인 작업을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 한다.

<br>

## ACID에 대해서 설명해 주세요.

<br>

### ① 정의

ACID는 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질

### ② 특징

1. 원자성(Atomicity)
    
    트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 된다.
    
    트랜잭션의 연산은 모든 연산이 완벽히 수행되어야 하며, 중간에 어떠한 문제가 발생한다면 트랜잭션은 실패해야 한다.
    
2. 일관성(Consistency)
    
    트랜잭션이 완료된 후에도, 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.
    
3. 고립성(Isolation)
    
    둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.
    
4. 지속성(Durability)
    
    트랜잭션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 한다.

<br>

## 트랜잭션 격리 수준(Transaction Isolation Levels)에 대해서 설명해 주세요.

<br>

### ① 정의

트랜잭션들끼리 일관성 있는 데이터를 얼마나 허용할 것인지 정해놓은 수준

고립 수준이 높을수록 일관성은 보자되나 그만큼 동시성이 떨어져 성능은 하락

### ② 필요성

효율적인 Locking 방법을 위해 필요

### ③ 이상 현상 종류

1. Dirty Read
    
    어떤 트랜잭션에서 아직 실행이 끝나지 않은 트랜잭션에 의한 변경사항을 보게 되는 경우
    
2. Non Repeatable Read
    
    어떤 트랜잭션이 같은 쿼리를 2번 실행하는데 그 사이에 다른 트랜잭션이 수정/삭제를 하는 경우
    
3. Phantom Read
    
    어떤 트랜잭션이 같은 쿼리를 2번 실행하는데 그 사이에 없던 레코드가 추가되어 같은 쿼리에 다른 값이 나오는 경우
    
    
### ④ 격리 수준 단계

1. **Read Uncommitted(Level 0)**
    
    트랜잭션이 처리중이거나, 아직 commit 되지 않은 데이터를 다른 트랙잭션이 조회 하는 것을 허용하는 수준
    
    ex) 트랜잭션1이 A라는 데이터를 B로 변경하는 동안 트랜잭션2가 데이터 B를 읽을 수 있다.
    
    ➖ Dirty Read, Non Repeatable Read, Phantom Read 발생 가능
    
2. **Read Committed(Level 1)**
    
    트랜잭션 수행이 완료되어 commit이 이루어진 트랜잭션만 다른 트랜잭션에서 조회가 가능한 수준
    
    ➖ Non Repeatable Read, Phantom Read 발생 가능
    
3. **Repeatable Read(Level 2)**
    
    특정 트랜잭션에서 조회하고 있는 데이터는 다른 트랜잭션에서 수정/삭제가 불가능한 수준
    
    데이터 삽입은 가능하다.
    
    ➖ Phantom Read 발생 가능
    
4. **Serializable(Level 3)**
    
    특정 트랜잭션에서 조회 하고 있는 데이터는 다른 트랜잭션에서 수정/삭제/삽입 모두 불가능한 수준
    
    모든 이상 현상 방지 가능하나 동시성이 떨어져서 성능 하락
    
<br>

## 정규화에 대해서 설명해 주세요.

<br>

### ① 정의

관계형 데이터 모델에서 중복과 변경 이상이 최소화도록 릴레이션의 구조, 스키마를 변경해 가는 과정

### ② 목적

- 데이터의 중복을 없애면서 불필요한 데이터를 최소화시킨다.
- 무결성을 지키고, 이상 현상을 방지한다.
- 테이블 구성을 논리적이고 직관적으로 할 수 있다.
- 데이터베이스 구조를 확장에 용이해진다.

### ③ 단계

- 제 1정규화(1NF)
    
    테이블 컬럼이 원자값(하나의 값)만 갖도록 테이블을 분리
    
    1. 각 컬럼이 하나의 속성만을 가져야 한다.
   
    2. 하나의 컬럼은 같은 종류나 타입(type)의 값을 가져야 한다.
    
    3. 각 컬럼이 유일한(unique) 이름을 가져야 한다.
    
    4. 컬럼의 순서가 상관없어야 한다.

- 제 2정규화(2NF)
    
    테이블의 모든 컬럼이 완전 함수적 종속을 만족하도록 테이블을 분리
    
    기본키가 복합키 일 때, 그 중 하나의 키만으로 다른 컬럼을 결정지으면 안됨
    
    
    1. 제 1정규형 만족
    
    2. 어떤 후보키에도 속하지 않는 모든 애트리뷰트들이 기본키에 완전 함수적 종속 만족
    
- 제 3정규화(3NF)
    
    테이블의 모든 컬럼이 이행적 종속을 만족하지 않도록 테이블을 분리
    
    1. 제 2정규형 만족
    
    2. 키가 아닌 애트리뷰트들이 기본키에 직접 종속

<br>

## JOIN에 대해서 설명해 주세요

<br>

### ① 정의

2개 이상의 테이블이나 데이터베이스를 연결하여 데이터를 검색하는 방법
테이블을 연결하려면, 적어도 하나의 칼럼을 서로 공유하고 있어야 하므로 이를 이용하여 데이터 검색에 활용한다.

### ② 종류

- INNER JOIN
    
    교집합으로, 기준 테이블과 JOIN 테이블의 중복된 데이터를 보여준다.
    
    ```sql
    SELECT
    A.NAME, B.AGE
    FROM EX_TABLE A
    INNER JOIN JOIN_TABLE B ON A.NO_EMP = B.NO_EMP
    ```
    
    ![image](https://user-images.githubusercontent.com/85394884/225945448-82a5a1d1-7ef4-4157-9e4b-d8714d7c349a.png)
    
- LEFT OUTER JOIN
    
    기준 테이블값(왼쪽) + JOIN 테이블과의 중복된 값을 보여준다.
    
    ```sql
    SELECT
    A.NAME, B.AGE
    FROM EX_TABLE A
    LEFT OUTER JOIN JOIN_TABLE B ON A.NO_EMP = B.NO_EMP
    ```
    
    ![image](https://user-images.githubusercontent.com/85394884/225945674-a208d036-93ff-4e0d-b6be-e68d168384c6.png)
    
- RIGHT OUTER JOIN
    
    기준 테이블값(오른쪽) + JOIN 테이블과의 중복된 값을 보여준다.
    
    ```sql
    SELECT
    A.NAME, B.AGE
    FROM EX_TABLE A
    RIGHT OUTER JOIN JOIN_TABLE B ON A.NO_EMP = B.NO_EMP
    ```
    
    ![image](https://user-images.githubusercontent.com/85394884/225945957-ee18cef3-19ef-4476-99c3-c391ace710e3.png)
    
- FULL OUTER JOIN
    
    합집합으로, 기준 테이블과 JOIN 테이블의 모든 데이터를 가져온다.
    
    ```sql
    SELECT
    A.NAME, B.AGE
    FROM EX_TABLE A
    FULL OUTER JOIN JOIN_TABLE B ON A.NO_EMP = B.NO_EMP
    ```
    
    ![image](https://user-images.githubusercontent.com/85394884/225945788-31654505-410e-4bfb-aed1-402e6ab07943.png)
    
- CROSS JOIN
    
    한 쪽 테이블의 모든 행들과 다른 테이블의 모든 행을 조인한다.
    
    ```sql
    SELECT
    A.NAME, B.AGE
    FROM EX_TABLE A
    CROSS JOIN JOIN_TABLE B
    ```
    
- SELF JOIN
    
    자기 자신을 JOIN한다.

<br>

## RDBMS vs NoSQL에 대해서 설명해 주세요.

<br>

- **RDBMS**
    
    장점
    - 정해진 스키마에 따라 데이터를 저장해야 하므로 명확한 데이터 구조를 보장한다.
    - 각 데이터를 중복없이 한 번만 저장할 수 있다.
    
    단점
    - 테이블간의 관계가 존재하기 때문에 시스템이 커질 시, JOIN이 많은 복잡한 쿼리가 발생할 수 있다.
    - 성능 향상을 위해서 scale-up만을 지원해 비용이 급격히 늘어날 수 있다.
    - 스키마의 존재로 데이터가 유연성이 부족하다.

- **NOSQL**
    
    장점
    - 스키마가 없기 때문에 유연하며 자유로운 데이터 구조를 보장한다.
    - 언제든 저장된 데이터를 조정하고 새로운 필드를 추가할 수 있다.
    - 데이터 분산에 용이하며, 성능 향상을 위한 scale-up, scale-out 모두 가능하다.
    
    단점
    - 데이터 중복이 발생할 수 있으며, 중복된 데이터 변경 시 모든 컬렉션에서 수정이 이루어져야 하는 번거로움이 있다.
    - 스키마가 없기 때문에 명확한 데이터 구조를 보장하진 못한다.

<br>

## Redis에 대해서 간단히 설명해주세요.

<br>

### ① 정의

인 메모리 기반의 고성능  key-value 데이터 구조 스토어

→ 일반적인 데이터베이스는 하드 디스크나 SSD에 저장하는 반면, Redis는 메모리(RAM)에 저장해 디스크 스캐닝 과정이 필요없어 매우 빠르다.

### ② Redis 영속성 보장 방법

- Snapshot으로 특정 지점을 설정해 디스크에 백업한다.
- AOF(Append Only File) :  (write/update) 쿼리들을 log파일에 저장해두고, 서버가 셧다운되면 재실행해서 다시 만들어 놓는다.

### ③ 특징

- 영속성을 지원하는 인 메모리 데이터 저장소
- String, Sets, Sorted Sets, Hashes, Lists의 다양한 자료 구조를 지원한다.
    - String : 가장 일반적인 key-value 구조의 형태
    - Sets : String의 집합, 여러 개의 값을 하나의 value에 넣을 수 있음(ex. 포스트 태그)
    - Sorted Sets : 정렬된 Set(ex. 랭킹 보드 서버 구현)
    - Lists : array 형식의 데이터 구조
- 싱글 스레드이기 때문에 한 번에 하나의 명령만 처리할 수 있다.(Thread Safe)
    - 그렇기 때문에 중간에 처리 시간이 긴 명령어가 들어오면 그 뒤에 명령어들은 모두 앞에 있는 명령어가 처리될 때까지 대기한다.
      (하지만 get, set 명령어의 경우 초당 10만 개 이상 처리할 수 있을 만큼 빠르다.)

<br>

## Redis와 Memcached의 차이에 대해서 설명해주세요.

<br>

### ① 공통점

- 인 메모리 기반 cache
- key-value 저장소
- RAM에 데이터 저장

### ② 차이점

- Memcached는 멀티스레드를 지원해서 멀티 프로세싱이 가능하고, Redis는 싱글 스레드 기반으로 동작한다.
- Memcached의 확장성은 scale-up을 통해서 얻을 수 있는 반면, Redis는 scale-out을 통해서 얻을 수 있다.
- 데이터 축출 시 Memcached의 경우, LRU(Least Recently Used) 알고리즘만을 채택하고 있지만, Redis는 다양하고 미세한 방법을 제공한다.
    - No Eviction : 데이터 축출 안하기 → 메모리 부족 시 에러 발생
    - All Keys LRU : LRU에 근거하여 축출
    - Volatile : LRU를 따르되, 만료 시점이 지정된ㄷ 것들에 한해서 축출 진행
    - All Keys Random : 랜덤하게 키 삭제
    - Volatile Random : 랜덤하게 키 삭제하되, 그 대상은 만료 시점이 지정된 것들로 한정
    - Volatile TTL : TTL값을 기반으로, 만료시점이 빨리 도래하는 순서대로 삭제
- Memcached의 경우 문자열 데이터만 지원하나, Redis는 다양한 데이터 타입을 지원한다.
- Memcached의 경우 데이터를 영속화할 수 있는 기능이 없지만, Redis의 경우 AOF 기반으로 데이터를 영속화할 수 있다.
- Redis는 낙관적 락 기반 트랜잭션을 지원한다.
- Redis는 Replication(데이터 복제), Pub/Sub의 기능을 제공한다.

<br>

## elastic search 에 대해서 간단히 설명해 주세요

<br>Elastic Search는 자바로 개발된 오픈소스 분산 검색엔진 입니다. 검색을 위해 단독으로 사용 가능하며, ELK 스택이라고 부르는 Logstash, Kibana를 추가적으로 사용합니다.

Inverted Index 구조로 데이터를 저장해서, 어떤 데이터가 어떤 위치에 있는지를 저장하기 때문에 전문(Full-text) 검색시에 RDBMS에 비해 뛰어난 성능을 보장합니다.



> ### ELK 스택
>
> 1. Logstash : 다양한 소스의 로그 또는 트랜잭션 데이터를 수집, 집계, 파싱하여 Elastic search로 전달
> 2. Elastic search : Logstach로 부터 받은 데이터를 검색 및 집계를 하여 필요한 관심있는 정보를 획득
> 3. Kibana : Elsasticsearch의 빠른 검색을 통해 데이터를 시각화 및 모니터링

<br>

> ### Elastic Search의 장점
>
> - Scale out
>   - 샤드를 통해 규모가 수평적으로 늘어날 수 있음
> - 고가용성
>   - Replica를 통해 데이터의 안전성을 보장
> - Schema Free
>   - Json 문서를 통해 데이터 검색을 수행하므로 스키마 개념이 없음
>
> ### Elastic Search의 단점
>
> - 실시간 처리가 불가능하다.
>   - elasticsearch는 인메모리 버퍼를 사용하므로 쓰기와 동시에 읽기 작업을 할 경우, 세그먼트가 생성되기 전까지는 해당 데이터를 검색할 수 없다.
> - 트랜잭션을 지원하지 않는다.
>   - 분산 시스템 구성의 특징 때문에 시스템적으로 비용 소모가 큰 트랜잭션 및 롤백을 지원하지 않는다.

<br>

## Elastic Search의 인덱스 구조와 RDBMS의 인덱스 구조의 차이에 대해 설명해주세요.

<br>

Elastic Search는 Inverted-Index 구조로 데이터를 저장합니다. 찾으려는 데이터와 그 데이터의 위치를 저장한 형태이고 RDBMS는 일반적으로 기본키나 유니크키를 인덱스로 설정하면, 설정한 인덱스를 기준으로 트리 형태로서 데이터를 보관합니다.

<br>

## Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대해 설명해주세요.

<br>like 검색은 데이터가 늘어날수록 검색해야 할 대상이 늘어나 시간도 오래 걸리고, row 안의 내용을 모두 읽어야 하기 때문에 기본적으로 속도가 느리다. 특히 row 안의 내용이 길다면 하나의 row를 읽더라도 시간이 오래 걸린다.

역색인을 사용하면 데이터가 늘어나도 찾아가야 할 행이 늘어나는 것이 아니라 역색인이 가리키는 id의 배열 값이 추가되는 것이므로 큰 속도의 저하 없이 여전히 빠른 속도로 검색이 가능하다.

<br>

## MongoDB에 대해서 간단히 설명해주세요.

Mongo DB 는 오픈소스 NoSQL 데이터베이스입니다. 데이터들을 key-value Binary JSON 형태로 보관하여 데이터 유연성이 뛰어나고 솔루션 자체적으로 샤딩을 통한 확장을 지원하기 때문에 쉽게 분산 처리를 할 수 있습니다. 또한, 복제 기능을 통해 동일한 데이터를 여러 서버에 저장하기 때문에 데이터 안정성이 뛰어나다는 특징이 있습니다.



<img src="https://raw.githubusercontent.com/buinq/imageServer/main/img/image-20230313191050931.png" alt="image-20230313191050931" style="zoom:67%;" />

<br>

## CAP 이론이란?

<br>

분산 시스템은 일관성(Consistency), 가용성(Availablity), 분단 허용성(Partition torlerance) 세 가지 속성중에서, 두 가지만 가질 수 있다는 이론입니다.

일관성은 동일한 시점에서 요청한 데이터는 항상 동일해야함을 의미합니다.

가용성은 모든 클라이언트의 read와 write에 대해 항상 응답이 가능해야함을 의미합니다. 시스템을 구성하는 어떤 요소 하나가 망가졌을 때 시스템 전체를 멈추게 만드는 요소가 존재해서는 안됩니다.

분단 허용성은 두 지역간 네트워크가 단절되거나 네트워크의 데이터가 유실되더라도 두 지역간 시스템은 서로 영향을 주지 않고 각 지역의 시스템이 정상적으로 동작해야함을 의미합니다.

> ### MySQL
>
> MySQL은 **그냥 사용했을 때엔 CA**에 속한다.
> main이 되는 master 노드가 있고 그 노드를 복제해 사용하는 slave가 있는 패러다임을 사용하기 때문이다.
> 이때 MySQL은 가용성(A)과 일관성(C)을 만족하게 된다.
> 설정하기에 따라 CP 또는 CA에 속할 수 있다.
>
> MySQL은 cluster 설정을 지원한다.
> **cluster 설정을 하면 MySQL은 CP를 만족하는 시스템**이 된다.
> data를 유지할만한 cluster 노드가 존재하지 않으면 cluster는 종료될 것이기 때문이다.

<br>

> ### 일관성 vs 가용성
>
> > CP (Consistency & Partition tolerance) - 일관성과 분할내성 조합
>
>  
>
> 분할된 노드에서 응답을 기다리는 경우에 시간 초과 오류 (timeout error)가 발생할 수 있다.
>
> CP는 원자성 읽기와 쓰기를 필요로 하는 비즈니스 로직에 좋은 선택이 될 것이다.
>
>  
>
> > AP (Availability & Partition tolerance) - 가용성과 분할 내성 조합
>
>  
>
> 응답 요청은 어떤 노드에서도 받을 수 있고 그 노드에서 준비되어있는 버전의 데이터를 반환한다. 이 뜻은 반환된 데이터는 최신 버전이 아닐 수 있다는 뜻이다. 모든 파티션에 새로운 데이터나 업데이트가 전파되는데 다소 시간이 걸릴 수 있다.
>
>  
>
> AP는 외부 장애에도 시스템을 유지해야 하고 데이터가 궁극적으로 일관성이 있기만 하면 되는 비즈니스 모델에 좋은 선택이다.

<br>

##  Eventual Consistency란?

<br>

Eventual Consistency란 결과적 일관성이라고도 불리고 CAP 이론에서 일관성을 포기했을 때, Consistency를 완전히 보장하지는 않지만, 결과적으로 언젠가는 Consistency가 보장됨을 의미합니다.

트랜잭션을 각각 수행하고 일관성이 달라진 부분은 나중에 일관성을 맞추는 개념입니다.
