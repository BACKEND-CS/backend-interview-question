# 목차

## 데이터베이스에서 인덱스를 사용하는 이유 및 장단점에 대해 설명해주세요.

<br>

### ① 목적

RDBMS에서 데이터 조회 성능 향상을 위해 사용

테이블의 컬럼을 색인화 하여 따로 파일로 저장한다.

→ 해당 테이블의 레코드(모든 행)을 Full scan하지 않는다.

→ 색인화 된 인덱스 파일 검색으로 검색 속도 향상

### ② 장점

검색 속도 향상

### ③ 단점

1. **타 성능에 악영향**
    
    인덱스는 데이터 조회(SELECT)를 제외한 모든 동작,
    
    INSERT, UPDATE, DELETE 성능에 영향을 미친다.
    
    → 인덱스를 걸어둔 컬럼의 데이터가 바뀌면 인덱스 테이블의 수정도 필요하기 때문에, 데이터의 삽입 / 수정 / 삭제 작업의 두 번 이루어지게 된다.
    

2. **추가 저장 공간 필요**
    
    DB에 저장된 데이터의 주소를 인덱스의 Key 값으로 가지려면 별도의 공간에 저장하므로 추가 저장 공간이 필요하다.
    
    때문에 인덱스를 사용하는 시스템을 설계할 때, 인덱스 영역을 전체 테이블 영역의 30 ~ 50%까지 잡아 놓을 만큼 저장 공간이 꽤나 많이 필요하다.
    

3. **공수 필요**
    
    인덱스를 생성하고 주기적으로 관리할 인력과 시간이 들어간다.
    
    ❓공수 : 일정한 작업에 필요한 인원 수를 노동 시간이나 노동 일로 나타낸 수치
   
<br>

## 트랜잭션에 대해서 설명해주세요.

<br>

데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위이다.

다른 말로, 작업의 완전성을 보장해주는 것이다. 

논리적인 작업을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 한다.

<br>

## ACID에 대해서 설명해주세요.

<br>

### ① 정의

ACID는 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질

### ② 특징

1. 원자성(Atomicity)
    
    트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 된다.
    
    트랜잭션의 연산은 모든 연산이 완벽히 수행되어야 하며, 중간에 어떠한 문제가 발생한다면 트랜잭션은 실패해야 한다.
    
2. 일관성(Consistency)
    
    트랜잭션이 완료된 후에도, 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.
    
3. 고립성(Isolation)
    
    둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.
    
4. 지속성(Durability)
    
    트랜잭션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 한다.

<br>

## 트랜잭션 격리 수준(Transaction Isolation Levels)에 대해서 설명해주세요.

<br>

### ① 정의

트랜잭션들끼리 일관성 있는 데이터를 얼마나 허용할 것인지 정해놓은 수준

고립 수준이 높을수록 일관성은 보자되나 그만큼 동시성이 떨어져 성능은 하락

### ② 필요성

효율적인 Locking 방법을 위해 필요

### ③ 이상 현상 종류

1. Dirty Read
    
    어떤 트랜잭션에서 아직 실행이 끝나지 않은 트랜잭션에 의한 변경사항을 보게 되는 경우
    
2. Non Repeatable Read
    
    어떤 트랜잭션이 같은 쿼리를 2번 실행하는데 그 사이에 다른 트랜잭션이 수정/삭제를 하는 경우
    
3. Phantom Read
    
    어떤 트랜잭션이 같은 쿼리를 2번 실행하는데 그 사이에 없던 레코드가 추가되어 같은 쿼리에 다른 값이 나오는 경우
    
    
### ④ 격리 수준 단계

1. **Read Uncommitted(Level 0)**
    
    트랜잭션이 처리중이거나, 아직 commit 되지 않은 데이터를 다른 트랙잭션이 조회 하는 것을 허용하는 수준
    
    ex) 트랜잭션1이 A라는 데이터를 B로 변경하는 동안 트랜잭션2가 데이터 B를 읽을 수 있다.
    
    ➖ Dirty Read, Non Repeatable Read, Phantom Read 발생 가능
    
2. **Read Committed(Level 1)**
    
    트랜잭션 수행이 완료되어 commit이 이루어진 트랜잭션만 다른 트랜잭션에서 조회가 가능한 수준
    
    ➖ Non Repeatable Read, Phantom Read 발생 가능
    
3. **Repeatable Read(Level 2)**
    
    특정 트랜잭션에서 조회하고 있는 데이터는 다른 트랜잭션에서 수정/삭제가 불가능한 수준
    
    데이터 삽입은 가능하다.
    
    ➖ Phantom Read 발생 가능
    
4. **Serializable(Level 3)**
    
    특정 트랜잭션에서 조회 하고 있는 데이터는 다른 트랜잭션에서 수정/삭제/삽입 모두 불가능한 수준
    
    모든 이상 현상 방지 가능하나 동시성이 떨어져서 성능 하락
    
<br>

## 정규화에 대해서 설명해주세요.

<br>

### ① 정의

관계형 데이터 모델에서 중복과 변경 이상이 최소화도록 릴레이션의 구조, 스키마를 변경해 가는 과정

### ② 목적

- 데이터의 중복을 없애면서 불필요한 데이터를 최소화시킨다.
- 무결성을 지키고, 이상 현상을 방지한다.
- 테이블 구성을 논리적이고 직관적으로 할 수 있다.
- 데이터베이스 구조를 확장에 용이해진다.

### ③ 단계

- 제 1정규화(1NF)
    
    테이블 컬럼이 원자값(하나의 값)만 갖도록 테이블을 분리
    
    1. 각 컬럼이 하나의 속성만을 가져야 한다.
   
    2. 하나의 컬럼은 같은 종류나 타입(type)의 값을 가져야 한다.
    
    3. 각 컬럼이 유일한(unique) 이름을 가져야 한다.
    
    4. 컬럼의 순서가 상관없어야 한다.

- 제 2정규화(2NF)
    
    테이블의 모든 컬럼이 완전 함수적 종속을 만족하도록 테이블을 분리
    
    기본키가 복합키 일 때, 그 중 하나의 키만으로 다른 컬럼을 결정지으면 안됨
    
    
    1. 제 1정규형 만족
    
    2. 어떤 후보키에도 속하지 않는 모든 애트리뷰트들이 기본키에 완전 함수적 종속 만족
    
- 제 3정규화(3NF)
    
    테이블의 모든 컬럼이 이행적 종속을 만족하지 않도록 테이블을 분리
    
    1. 제 2정규형 만족
    
    2. 키가 아닌 애트리뷰트들이 기본키에 직접 종속


## elastic search 에 대해서 간단히 설명해 주세요

<br>Elastic Search는 자바로 개발된 오픈소스 분산 검색엔진 입니다. 검색을 위해 단독으로 사용 가능하며, ELK 스택이라고 부르는 Logstash, Kibana를 추가적으로 사용합니다.

Inverted Index 구조로 데이터를 저장해서, 어떤 데이터가 어떤 위치에 있는지를 저장하기 때문에 전문(Full-text) 검색시에 RDBMS에 비해 뛰어난 성능을 보장합니다.



> ### ELK 스택
>
> 1. Logstash : 다양한 소스의 로그 또는 트랜잭션 데이터를 수집, 집계, 파싱하여 Elastic search로 전달
> 2. Elastic search : Logstach로 부터 받은 데이터를 검색 및 집계를 하여 필요한 관심있는 정보를 획득
> 3. Kibana : Elsasticsearch의 빠른 검색을 통해 데이터를 시각화 및 모니터링

<br>

> ### Elastic Search의 장점
>
> - Scale out
>   - 샤드를 통해 규모가 수평적으로 늘어날 수 있음
> - 고가용성
>   - Replica를 통해 데이터의 안전성을 보장
> - Schema Free
>   - Json 문서를 통해 데이터 검색을 수행하므로 스키마 개념이 없음
>
> ### Elastic Search의 단점
>
> - 실시간 처리가 불가능하다.
>   - elasticsearch는 인메모리 버퍼를 사용하므로 쓰기와 동시에 읽기 작업을 할 경우, 세그먼트가 생성되기 전까지는 해당 데이터를 검색할 수 없다.
> - 트랜잭션을 지원하지 않는다.
>   - 분산 시스템 구성의 특징 때문에 시스템적으로 비용 소모가 큰 트랜잭션 및 롤백을 지원하지 않는다.

<br>

## Elastic Search의 인덱스 구조와 RDBMS의 인덱스 구조의 차이에 대해 설명해주세요.

<br>

Elastic Search는 Inverted-Index 구조로 데이터를 저장합니다. 찾으려는 데이터와 그 데이터의 위치를 저장한 형태이고 RDBMS는 일반적으로 기본키나 유니크키를 인덱스로 설정하면, 설정한 인덱스를 기준으로 트리 형태로서 데이터를 보관합니다.

<br>

## Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대해 설명해주세요.

<br>like 검색은 데이터가 늘어날수록 검색해야 할 대상이 늘어나 시간도 오래 걸리고, row 안의 내용을 모두 읽어야 하기 때문에 기본적으로 속도가 느리다. 특히 row 안의 내용이 길다면 하나의 row를 읽더라도 시간이 오래 걸린다.

역색인을 사용하면 데이터가 늘어나도 찾아가야 할 행이 늘어나는 것이 아니라 역색인이 가리키는 id의 배열 값이 추가되는 것이므로 큰 속도의 저하 없이 여전히 빠른 속도로 검색이 가능하다.
