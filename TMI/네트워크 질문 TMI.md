# 목차

1. [도메인 주소를 입력하면 일어나는 일](#도메인-주소를-입력하면-일어나는-일)
2. [TCP와 UDP의 특징](#tcp와-udp의-특징)
3. [TCP 3 way 와 4 way handshake](#tcp-3-way-와-4-way-handshake)
4. [HTTP 와 HTTPS 의 차이점](#http-와-https-의-차이점)
5. [Https SSL Handshake란](#https-ssl-handshake란)
6. [HTTP 메서드의 정의 및 역할](#http-메서드의-정의-및-역할)
7. [RESTful 이란 무엇이고 REST는 무엇인가](#restful-이란-무엇이고-rest는-무엇인가)
8. [OSI 모델](#osi-모델)
9. [TCP IP 모델이란](#tcp-ip-모델이란)
10. [Apache와 Nginx는 OSI 7계층 중 어디서 작동하는지 설명해보세요](#apache와-nginx는-osi-7계층-중-어디서-작동하는지-설명해보세요)
11. [Blocking과 Non blocking](#blocking과-non-blocking)
12. [Synchronous과 Asynchronous](#synchronous과-asynchronous)


## 도메인 주소를 입력하면 일어나는 일

<br>

입력한 도메인 주소로 웹사이트를 호스팅하는 서버의 IP 주소를 조회해야합니다.

IP주소를 조회하는 과정은 매우 빨라야 하기 때문에, 웹 브라우저는 도메인 주소 정보가 **①캐싱되어** 있는지 먼저 확인합니다.

캐싱된 기록이 없다면 ISP가 구축한 **②DNS**서버에 DNS 쿼리를 사용해서 해당 도메인 주소와 일치하는 IP주소를 전달받습니다.

찾은 IP주소에 **③TCP/IP 프로토콜**을 이용해 연결을 요청합니다. 신뢰할 수 있는 연결을 하기위해 TCP 3-way HandShake를 진행합니다.

연결이 된 후, 브라우저는 GET 요청으로 웹페이지를 요구합니다.

서버는 웹 브라우저에게 HTML파일로 응답하고 브라우저는 HTML을 랜더링하여 사용자에게 구글 화면을 보여줍니다.



### ① DNS 정보 캐싱

> CPU와 RAM 사이에 용량은 작지만 속도가 빠른 작은 메모리가 있는데, 이를 캐시라고 한다.
>
> 브라우저 캐시(DNS쿼리 사용) -> OS 캐시(systemcall 사용) -> 라우터 캐시 -> ISP 캐시 순으로 접근하려는 URL과 일치하는 정보가 저장되어 있는지 확인한다.
>
> DNS 서버에 요청하는 과정을 생략할 수 있게 된다.

<br>

### ② DNS

> 웹사이트의 도메인 주소와 IP주소를 알고 있는 서버이다.
>
> 브라우저가 DNS서버에 특정 도메인 주소를 전달하면, DNS 서버는 IP주소를 브라우저에게 알려준다.
>
> 브라우저는 전달받은 IP주소로 요청한다.

<br>

### ③TCP/IP 연결

> 1. 클라이언트는 요청 서버에 SYN 패킷을 보내 연결을 요청한다.
> 2. 요청을 수락한다면, 서버는 클라이언트에게 SYN 패킷과 ACK 패킷으로 응답한다.
> 3. 클라이언트는 ACK 패킷을 보내 연결 확립 응답을 보낸다.



<br>



## TCP와 UDP의 특징

<br>

TCP와 UDP는 전송계층에서 사용되는 프로토콜입니다.

포트 번호를 이용해 주소를 지정하고 데이터 오류검사를 위한 체크섬이 존재한다는 공통점이 있습니다.

<br>

TCP는 연결 지향적 프로토콜로서, 클라이언트와 서버가 연결된 상태에서 데이터를 주고받는 통신 방식입니다.(3-way handshake로 연결, 4-way handshake로 연결 해제)

고정된 네트워크 경로로 통신하기 때문에

데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지, 네트워크 내의 패킷 수가 과도하게 증가하지 않도록 조절할 수 있습니다.

신뢰성 향상을 위한 연결과정 때문에, UDP보다 속도는 느리고 1:1 통신만 가능하며, 패킷 순서 보장 때문에 중간에 패킷이 유실되면 재전송해야해서 통신 속도가 저하될 수 있습니다.



UDP는 비연결형 프로토콜입니다.

패킷의 전송 순서가 바뀔 수 있고 데이터 수신 여부를 확인하지 않아 신뢰성이 낮다. 하지만 속도가 빠르다는 이점이 있어 동영상 스트리밍 서비스와 같은 곳에 사용됩니다.

참고로, 헤더 설정을 추가하면 커스터마이징이 가능하기 때문에 신뢰성을 보장받도록 할 수 있습니다. HTTP/3가 UDP기반 통신을 적용한 이유중에 하나로 볼 수 있습니다.

> HTTP/3 (웹 상 정보 전달 프로토콜) 는 QUIC(Quick UDP Internet Connection)이라는 프로토콜 기반이다.

<br>

## TCP 3 way 와 4 way handshake

<img src="https://raw.githubusercontent.com/buinq/imageServer/main/img/image-20230222220547314.png" alt="image-20230222220547314" style="zoom:125%;" />

TCP는 연결 지향형 프로토콜이기 때문에, 송신측과 수신측이 연결되어야 합니다.

이를 위해서, TCP 헤더에 TCP 플래그가 있고, TCP 플래그에는 ACK · SYN · FIN 가 사용됩니다.

초기값은 0이고, 이 플래그로 3-way / 4-way handshake를 진행합니다.

1. 연결을 요청할 때, SYN 플래그로 요청을 보냅니다.

2. 연결을 받은 쪽은, 받은 SYN 플래그에 대한 응답으로 ACK 플래그와 연결 확립 요청을 위해 SYN 플래그를 보냅니다.

3. 연결을 처음에 요청했던 쪽은, 확립에 대한 응답으로 ACK 플래그를 보내는 것으로 3-way handshake는 마무리 됩니다.



연결을 종료하는 과정인 4-way handshake 에서는 FIN 플래그와 ACK 플래그를 사용합니다.

1. 연결 종료 요청을 FIN 플래그와 함께 보냅니다.
2. 종료 요청을 받은 쪽은 ACK 플래그로 응답합니다.
3. 요청 받은 쪽도 FIN 플래그로 연결 종료 확립 요청을 보냅니다.
4. 처음에 연결 종료 요청을 했던 쪽은, ACK 플래그로 연결 종료 확립 응답을 보내는 것으로 마무리 됩니다.

<br>

## HTTP 와 HTTPS 의 차이점



http는 애플리케이션 레벨의 프로토콜이고 기본적으로 80포트를 사용합니다. HTTP는 Method, Path, Version, Headers, Body로 구성됩니다.

암호화 되어있지 않는 평문 데이터를 전송하는 프로토콜이기 때문에, 보안상 취약점이 있었고 이를 해결하기 위해 HTTPS가 나타났습니다.

Https는 기본적으로 443포트를 사용하고 서버와 브라우저 사이에 TLS나 SSL(Secure Socket Layer) 프로토콜로 데이터를 암호화해 통신을 합니다.

<br>

## Https SSL Handshake란



SSL은 암호화 기법으로 대칭키 방식과 비대칭키 방식을 사용합니다.

<img src="https://raw.githubusercontent.com/buinq/imageServer/main/img/image-20230223222741693.png" alt="image-20230223222741693" height="400" />

대칭키 방식은 동일한 키로 암호화와 복호화를 수행하는 방법입니다.

같은 키를 가지고 있어 **대칭키**라 불리는 것입니다.

암호화 복호화 처리에서는 속도가 빠르다는 장점이 있지만, 누군가 키를 탈취해가면 보안상 취약해진다는 단점이 있습니다.

<img src="https://raw.githubusercontent.com/buinq/imageServer/main/img/image-20230223223048710.png" alt="image-20230223223048710" height="400" />

비대칭키 방식은 서로 다른 키로 복호화를 수행하는 방식입니다.

공개키로 암호화한 데이터는 개인키로만 복호화 할 수 있고, 개인키로 암호화한 데이터는 공개키로만 복호화할 수 있습니다.

따라서 누군가 공개키를 탈취해간다고 해도, 공개키로 암호화한 데이터를 복호화할 수 없습니다.

단, 비대칭키 방식은 대칭키 방식보다 보안상 유리하지만 암호화 연산 시간이 더 소요되어 비용이 크다는 단점이 있습니다.



SSL handshake 는 단점을 보안하기위해, 대칭키 방식과 비대칭키 방식을 혼합해서 사용합니다.

<img src="https://raw.githubusercontent.com/buinq/imageServer/main/img/image-20230223223914314.png" alt="image-20230223223914314" height="400" />

간략하게 설명하면, 서버는 자신이 검증된 서버라는 것을 증명하기 위해 CA(인증기관)에 심의를 받고 SSL인증서를 얻을 수 있습니다.

따라서, 사용자는 안전한 통신을 위해서 서버에게 SSL 인증서를 요구하고, 서버는 SSL 인증서를 전달합니다.

받은 SSL 인증서가 가짜일 수 있기 때문에, 사용자는 다시 CA에 검증을 받고 검증이 완료되면 서버의 개인키와 짝을 이루는 공개키를 전달합니다.



<img src="https://raw.githubusercontent.com/buinq/imageServer/main/img/image-20230223224135146.png" alt="image-20230223224135146" height="400" />

이제, 사용자는 공개키를, 서버는 개인키를 갖고 있기 때문에 데이터를 주고받으면 될 것 같지만 비대칭키 방식은 보안은 좋지만 그만큼 발생되는 비용이 있기 때문에 여기서 대칭키 방식을 접목합니다.

<img src="https://raw.githubusercontent.com/buinq/imageServer/main/img/image-20230223224355957.png" alt="image-20230223224355957" height="400" />



사용자는 그 공개키로 자신의 대칭키를 암호화 한뒤, 서버에 전송합니다.

해커가 대칭키를 가로챈다고해도, 공개키로 암호화된 대칭키를 복호화할 수 없습니다.

서버는 개인키로 공개키에 의해 암호화된 대칭키를 복호화 할 수 있습니다.

그렇게 양측이 대칭키를 갖고 있을 수 있게 되고, **대칭키 방식을 활용할 수 있게 됩니다.**

## HTTP 메서드의 정의 및 역할

<br>

HTTP 메서드는 대표적으로 GET · POST · PUT · DELETE · PATCH가 있고, HEAD · OPTIONS · CONNECT · TRACE 총 9개의 메서드가 있습니다.

> HEAD : GET과 동일하지만 메시지 부분을 제외하고 상태 줄과 헤더만 반환
>
> OPTIONS : 대상 리소스에 대한 통신 가능 옵션을 설명(주로 CORS에서 사용)
>
> CONNECT : 대상 자원으로 식별되는 서버에 대한 터널을 설정
>
> TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행

URI를 설계할 때, 리소스와 해당 리소스를 대상으로하는 행위를 분리해야합니다.

리소스의 이름 및 위치는 URI로 표현하고 행위는 HTTP 메서드를 사용해서 구분합니다.

GET 메서드는 리소스를 조회할 때 사용하고 전달하고 싶은 데이터는 쿼리 파라미터로 전달합니다. GET은 캐시로 사용할 수 있다는 특정이 있습니다.

> 메시지 바디로 전달하는 것은 지원하지 않는 곳이 많아서 권장하지 않음

POST 메서드는 메시지 바디로 들어온 데이터를 등록하거나 특정 프로세스를 처리하는 작업에 사용합니다. 멱등성이 성립하지 않습니다.

> - 멱등성이 성립하지 않는다 = 똑같은 요청을 하면 한번 요청했을 때와 결과가 달라진다.
> - POST의 경우 캐시가 가능하지만 본문 내용까지 캐시 키로 고려해야해서 구현이 쉽지 않다.

PUT 요청은 리소스의 위치를 지정하여 요청한 리소스로 대체하고 해당 리소스가 없으면 생성하게 처리합니다.

PATCH 리소스를 부분적으로 변경하게 처리할때 사용합니다.

DELETE 리소스를 삭제 처리할때 사용합니다.

<br>

## RESTful 이란 무엇이고 REST는 무엇인가

<br>



REST는 Representational State Transfer의 약자로 웹의 장점을 활용할 수 있는 아키텍쳐 스타일입니다.

URI를 리소스와 리소스의 위치만으로 표현해야하고 리소스에 대한 행위는 HTTP 메서드로 표현하는 것입니다.

RESTful 하다는 것은 REST 설계 규칙을 잘 지켰다는 것을 의미합니다.

<br>



## OSI 모델

<br>
OSI7계층은 네트워크 통신을 구성하는 요소들 7개의 계층으로 표준화 한 것입니다. 이렇게 표준화하는 것의 장점은 통신이 일어나는 과정을 단계별로 파악할 수 있어, 문제가 발생하면 해당 문제를 해결하기 용이해집니다.

<img src="https://raw.githubusercontent.com/buinq/imageServer/main/img/image-20230227011229860.png" alt="image-20230227011229860" style="zoom:80%;" />

물리 계층, 데이터 링크 계층, 네트워크 계층, 전송 계층, 세션 계층, 표현 계층, 응용계층이 있습니다.

<br>

## TCP IP 모델이란?

TCP/IP 모델은 OSI 모델을 바탕으로 실생활에 사용하기 위해 만들어졌습니다.

물리계층과 데이터링크 계층이 TCP/IP 모델의 하나의 계층이고

네트워크 계층, 전송계층 그리고 세션, 표현, 응용계층이 하나의 계층입니다.



| TCP/IP 4계층                       | 역할                                             | 데이타 단위  | 전송주소 | 예시                                                    | 장비           |
| ---------------------------------- | ------------------------------------------------ | ------------ | -------- | ------------------------------------------------------- | -------------- |
| 응용 계층(Application)             | 응용프로그램 간의 데이타 송수신                  | Data/Message | -        | 파일 전송, 이메일, FTP, HTTP, SSH, Telnet, DNS, SMTP 등 | -              |
| 전송 계층(Transport)               | 호스트 간의 자료 송수신                          | Segment      | Port     | TCP, UDP, RTP, RTCP 등                                  | 게이트웨이     |
| 인터넷 계층(Internet)              | 데이타 전송을 위한 논리적 주소 지정 및 경로 지정 | Packet       | IP       | IP, ARP, ICMP, RARP, OSPF                               | 라우터         |
| 네트워크 연결 계층(Network Access) | 실제 데이타인 프레임을 송수신                    | Frame        | MAC      | Ethernet, PPP, Token Ring 등                            | 브리지, 스위치 |

1) L4 응용계층(Application Layer)       
   사용자와 가장 가까운 계층으로, 사용자가 소프트웨어 Application과 소통할 수 있게 해줍니다. application들이 데이터를 교환하기 위해 사용하는 프로토콜입니다.
2) L3 전송 계층(Transport Layer)        
   통신 노드간의 연결 제어 및 자료 송수신을 담당합니다. 애플리케이션 계층의 세션과 데이터그램 통신 서비스를 제공합니다.
3) L2 인터넷 계층(Internet Layer)       
   네트워크상 최종 목적지까지 정확하게 연결되도록 연결성을 제공합니다. 단말을 구분하기 위해 논리적인 주소인 IP를 할당합니다. 라우팅 기능을 처리합니다.
4) L1 네트워크 연결 계층(Network Access Layer/Network Interface     Layer)      
   물리적으로 데이터가 네트워크를 통해 어떻게 전송되는지 정의합니다. 논리주소 IP가 아닌 물리주소 Mac을 참조해 장비간에 전송을 담당합니다. 



<br>

## Apache와 Nginx는 OSI 7계층 중 어디서 작동하는지 설명해보세요

<br>

Nginx와 Apache는 웹서버(프록시 서버)이고  HTTP 프로토콜을 이용하여 html 데이터를 클라이언트에게 제공합니다.

HTTP 프로토콜은 OSI 7계층 중 응용계층에 있기 때문에 웹서버는 응용계층에서 작동합니다.

> 웹 페이지에 필요한 정적 데이터와 페이지 갱신에 필요한 동적 데이터를 하나의 서버에서 처리한다면, 부하가 커지게 되고 처리가 지연됨에 따라 수행 속도가 느려질 것이다.
>
> 그래서 `Web Server`와 `WAS(Web Application Server)` 같은 개념이 생겨나게 된다.
>
> `Web Server` 는 클라이언트의 요청을 처리하는 기능을 담당하고, `WAS(Web Application Server)` 는 DB 조회나 다양한 로직을 처리하는 기능을 담당한다.
>
> `Web Server`는 클라이언트가 HTML, CSS 와 같은 정적 데이터를 요청하면 앞단에서 빠르게 제공하고, 동적 데이터가 필요하면 `WAS` 에 요청을 보내고, `WAS` 가 처리한 데이터를 클라이언트에 전달한다.

<br>
<img src="https://raw.githubusercontent.com/buinq/imageServer/main/img/image-20230227134853510.png" alt="image-20230227134853510"  />

<br>

## Blocking과 Non blocking

<br>

- 호출된 함수가 자신이 할 일을 모두 마칠 때까지 제어권을 계속 가지고서 호출한 함수에게 제어권을 바로 돌려주지 않으면 Blocking입니다.

- 바로 제어권을 건네주어 호출한 함수가 다른 일을 할 수 있도록 해주면 Non-blocking입니다.

<br>

## Synchronous과 Asynchronous

<br>

- 호출된 함수의 수행 결과 및 종료를 호출한 함수가 신경쓰는 것을 Sync라 합니다. 즉, 호출한 함수는 호출된 함수가 끝날때까지 기다려야합니다.
- 호출된 함수의 수행 결과 및 종료를 호줄된 함수만 혼자 신경써서 처리하는 것을 Async라 합니다. 호출한 함수는 호출된 함수의 작업을 기다리지 않아도 됩니다.





### Blocking & Synchronous

> 나 : 대표님, 개발자 좀 더 뽑아주세요..
>
> 대표님 : 오케이, 잠깐만 거기 계세요!
> 
> 나 : …?!!
> 
> 대표님 : (채용 공고 등록.. 지원자 연락.. 면접 진행.. 연봉 협상..)
> 
> 나 : (과정 지켜봄.. 궁금함.. 어차피 내 일 하러는 못 가고 계속 서 있음)

### Blocking & Asynchronous

> 나 : 대표님, 개발자 좀 더 뽑아주세요..
> 
> 대표님 : 오케이, 잠깐만 거기 계세요!
> 
> 나 : …?!!
> 
> 대표님 : (채용 공고 등록.. 지원자 연락.. 면접 진행.. 연봉 협상..)
> 
> 나 : (안 궁금함.. 지나가는 말로 여쭈었는데 붙잡혀버림.. 딴 생각.. 못 가고 계속 서 있음)

### Non-blocking & Synchronous

> 나 : 대표님, 개발자 좀 더 뽑아주세요..
> 
> 대표님 : 알겠습니다. 가서 볼 일 보세요.
> 
> 나 : 넵!
> 
> 대표님 : (채용 공고 등록.. 지원자 연락.. 면접 진행.. 연봉 협상..)
> 
> 나 : 채용하셨나요?
> 
> 대표님 : 아직요.
> 
> 나 : 채용하셨나요?
> 
> 대표님 : 아직요.
> 
> 나 : 채용하셨나요?
> 
> 대표님 : 아직요~!!!!!!

### Non-blocking & Asynchronous

> 나 : 대표님, 개발자 좀 더 뽑아주세요..
> 
> 대표님 : 알겠습니다. 가서 볼 일 보세요.
> 
> 나 : 넵!
> 
> 대표님 : (채용 공고 등록.. 지원자 연락.. 면접 진행.. 연봉 협상..)
> 
> 나 : (열일중..)
> 
> 대표님 : 한 분 모시기로 했습니다~!
> 
> 나 : 😍

출처 : https://musma.github.io/2019/04/17/blocking-and-synchronous.html
